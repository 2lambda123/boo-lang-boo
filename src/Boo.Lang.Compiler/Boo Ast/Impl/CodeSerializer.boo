#region license
// Copyright (c) 2009 Rodrigo B. de Oliveira (rbo@acm.org)
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
// 
//     * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//     * Neither the name of Rodrigo B. de Oliveira nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#endregion

//
// DO NOT EDIT THIS FILE!
//
// This file was generated automatically by Boo astgen.boo.
//

namespace Boo.Lang.Compiler.Ast

public partial class CodeSerializer:
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as TypeMemberModifiers) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as TypeMemberModifiers) as Expression:
		return SerializeEnum("TypeMemberModifiers", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as MethodImplementationFlags) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as MethodImplementationFlags) as Expression:
		return SerializeEnum("MethodImplementationFlags", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as ParameterModifiers) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as ParameterModifiers) as Expression:
		return SerializeEnum("ParameterModifiers", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as ExceptionHandlerFlags) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as ExceptionHandlerFlags) as Expression:
		return SerializeEnum("ExceptionHandlerFlags", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as GenericParameterConstraints) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as GenericParameterConstraints) as Expression:
		return SerializeEnum("GenericParameterConstraints", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as StatementModifierType) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as StatementModifierType) as Expression:
		return SerializeEnum("StatementModifierType", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as BinaryOperatorType) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as BinaryOperatorType) as Expression:
		return SerializeEnum("BinaryOperatorType", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as BinaryOperatorKind) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as BinaryOperatorKind) as Expression:
		return SerializeEnum("BinaryOperatorKind", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def ShouldSerialize(value as UnaryOperatorType) as bool:
		return (value cast long) != 0;
	
	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	public def Serialize(value as UnaryOperatorType) as Expression:
		return SerializeEnum("UnaryOperatorType", (value cast long))

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCompileUnit(node as Boo.Lang.Compiler.Ast.CompileUnit) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CompileUnit"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modules):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modules"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ModuleCollection", node.Modules)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnTypeMemberStatement(node as Boo.Lang.Compiler.Ast.TypeMemberStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.TypeMemberStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.TypeMember):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "TypeMember"),
					Serialize(node.TypeMember)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnExplicitMemberInfo(node as Boo.Lang.Compiler.Ast.ExplicitMemberInfo) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ExplicitMemberInfo"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.InterfaceType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "InterfaceType"),
					Serialize(node.InterfaceType)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnSimpleTypeReference(node as Boo.Lang.Compiler.Ast.SimpleTypeReference) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SimpleTypeReference"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.IsPointer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsPointer"),
					Serialize(node.IsPointer)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnArrayTypeReference(node as Boo.Lang.Compiler.Ast.ArrayTypeReference) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ArrayTypeReference"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.IsPointer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsPointer"),
					Serialize(node.IsPointer)));

		if ShouldSerialize(node.ElementType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ElementType"),
					Serialize(node.ElementType)));

		if ShouldSerialize(node.Rank):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Rank"),
					Serialize(node.Rank)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCallableTypeReference(node as Boo.Lang.Compiler.Ast.CallableTypeReference) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CallableTypeReference"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.IsPointer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsPointer"),
					Serialize(node.IsPointer)));

		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.ReturnType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnType"),
					Serialize(node.ReturnType)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnGenericTypeReference(node as Boo.Lang.Compiler.Ast.GenericTypeReference) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.GenericTypeReference"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.IsPointer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsPointer"),
					Serialize(node.IsPointer)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.GenericArguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericArguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.GenericArguments)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnGenericTypeDefinitionReference(node as Boo.Lang.Compiler.Ast.GenericTypeDefinitionReference) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.GenericTypeDefinitionReference"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.IsPointer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsPointer"),
					Serialize(node.IsPointer)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.GenericPlaceholders):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericPlaceholders"),
					Serialize(node.GenericPlaceholders)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCallableDefinition(node as Boo.Lang.Compiler.Ast.CallableDefinition) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CallableDefinition"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		if ShouldSerialize(node.ReturnType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnType"),
					Serialize(node.ReturnType)));

		if ShouldSerialize(node.ReturnTypeAttributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnTypeAttributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.ReturnTypeAttributes)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnNamespaceDeclaration(node as Boo.Lang.Compiler.Ast.NamespaceDeclaration) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.NamespaceDeclaration"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnImport(node as Boo.Lang.Compiler.Ast.Import) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Import"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		if ShouldSerialize(node.AssemblyReference):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "AssemblyReference"),
					Serialize(node.AssemblyReference)));

		if ShouldSerialize(node.Alias):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Alias"),
					Serialize(node.Alias)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnModule(node as Boo.Lang.Compiler.Ast.Module) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Module"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Members):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Members"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeMemberCollection", node.Members)))

		if ShouldSerialize(node.BaseTypes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "BaseTypes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.BaseTypes)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		if ShouldSerialize(node.Namespace):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Namespace"),
					Serialize(node.Namespace)));

		if ShouldSerialize(node.Imports):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Imports"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ImportCollection", node.Imports)))

		if ShouldSerialize(node.Globals):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Globals"),
					Serialize(node.Globals)));

		if ShouldSerialize(node.AssemblyAttributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "AssemblyAttributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.AssemblyAttributes)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnClassDefinition(node as Boo.Lang.Compiler.Ast.ClassDefinition) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ClassDefinition"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Members):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Members"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeMemberCollection", node.Members)))

		if ShouldSerialize(node.BaseTypes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "BaseTypes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.BaseTypes)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnStructDefinition(node as Boo.Lang.Compiler.Ast.StructDefinition) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.StructDefinition"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Members):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Members"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeMemberCollection", node.Members)))

		if ShouldSerialize(node.BaseTypes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "BaseTypes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.BaseTypes)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnInterfaceDefinition(node as Boo.Lang.Compiler.Ast.InterfaceDefinition) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.InterfaceDefinition"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Members):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Members"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeMemberCollection", node.Members)))

		if ShouldSerialize(node.BaseTypes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "BaseTypes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.BaseTypes)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnEnumDefinition(node as Boo.Lang.Compiler.Ast.EnumDefinition) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.EnumDefinition"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Members):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Members"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeMemberCollection", node.Members)))

		if ShouldSerialize(node.BaseTypes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "BaseTypes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.BaseTypes)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnEnumMember(node as Boo.Lang.Compiler.Ast.EnumMember) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.EnumMember"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Initializer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Initializer"),
					Serialize(node.Initializer)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnField(node as Boo.Lang.Compiler.Ast.Field) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Field"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		if ShouldSerialize(node.Initializer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Initializer"),
					Serialize(node.Initializer)));

		if ShouldSerialize(node.IsVolatile):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsVolatile"),
					Serialize(node.IsVolatile)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnProperty(node as Boo.Lang.Compiler.Ast.Property) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Property"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.Getter):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Getter"),
					Serialize(node.Getter)));

		if ShouldSerialize(node.Setter):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Setter"),
					Serialize(node.Setter)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		if ShouldSerialize(node.ExplicitInfo):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ExplicitInfo"),
					Serialize(node.ExplicitInfo)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnEvent(node as Boo.Lang.Compiler.Ast.Event) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Event"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Add):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Add"),
					Serialize(node.Add)));

		if ShouldSerialize(node.Remove):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Remove"),
					Serialize(node.Remove)));

		if ShouldSerialize(node.Raise):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Raise"),
					Serialize(node.Raise)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnLocal(node as Boo.Lang.Compiler.Ast.Local) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Local"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnBlockExpression(node as Boo.Lang.Compiler.Ast.BlockExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.BlockExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.ReturnType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnType"),
					Serialize(node.ReturnType)));

		if ShouldSerialize(node.Body):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Body"),
					Serialize(node.Body)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnMethod(node as Boo.Lang.Compiler.Ast.Method) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Method"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		if ShouldSerialize(node.ReturnType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnType"),
					Serialize(node.ReturnType)));

		if ShouldSerialize(node.ReturnTypeAttributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnTypeAttributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.ReturnTypeAttributes)))

		if ShouldSerialize(node.Body):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Body"),
					Serialize(node.Body)));

		if ShouldSerialize(node.Locals):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Locals"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.LocalCollection", node.Locals)))

		if ShouldSerialize(node.ImplementationFlags):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ImplementationFlags"),
					Serialize(node.ImplementationFlags)));

		if ShouldSerialize(node.ExplicitInfo):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ExplicitInfo"),
					Serialize(node.ExplicitInfo)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnConstructor(node as Boo.Lang.Compiler.Ast.Constructor) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Constructor"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		if ShouldSerialize(node.ReturnType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnType"),
					Serialize(node.ReturnType)));

		if ShouldSerialize(node.ReturnTypeAttributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnTypeAttributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.ReturnTypeAttributes)))

		if ShouldSerialize(node.Body):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Body"),
					Serialize(node.Body)));

		if ShouldSerialize(node.Locals):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Locals"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.LocalCollection", node.Locals)))

		if ShouldSerialize(node.ImplementationFlags):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ImplementationFlags"),
					Serialize(node.ImplementationFlags)));

		if ShouldSerialize(node.ExplicitInfo):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ExplicitInfo"),
					Serialize(node.ExplicitInfo)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnDestructor(node as Boo.Lang.Compiler.Ast.Destructor) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Destructor"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Parameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Parameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ParameterDeclarationCollection", node.Parameters)))

		if ShouldSerialize(node.GenericParameters):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericParameters"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclarationCollection", node.GenericParameters)))

		if ShouldSerialize(node.ReturnType):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnType"),
					Serialize(node.ReturnType)));

		if ShouldSerialize(node.ReturnTypeAttributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ReturnTypeAttributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.ReturnTypeAttributes)))

		if ShouldSerialize(node.Body):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Body"),
					Serialize(node.Body)));

		if ShouldSerialize(node.Locals):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Locals"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.LocalCollection", node.Locals)))

		if ShouldSerialize(node.ImplementationFlags):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ImplementationFlags"),
					Serialize(node.ImplementationFlags)));

		if ShouldSerialize(node.ExplicitInfo):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ExplicitInfo"),
					Serialize(node.ExplicitInfo)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnParameterDeclaration(node as Boo.Lang.Compiler.Ast.ParameterDeclaration) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ParameterDeclaration"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnGenericParameterDeclaration(node as Boo.Lang.Compiler.Ast.GenericParameterDeclaration) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.GenericParameterDeclaration"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.BaseTypes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "BaseTypes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.BaseTypes)))

		if ShouldSerialize(node.Constraints):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Constraints"),
					Serialize(node.Constraints)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnDeclaration(node as Boo.Lang.Compiler.Ast.Declaration) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Declaration"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnAttribute(node as Boo.Lang.Compiler.Ast.Attribute) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Attribute"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Arguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Arguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionCollection", node.Arguments)))

		if ShouldSerialize(node.NamedArguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "NamedArguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionPairCollection", node.NamedArguments)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnStatementModifier(node as Boo.Lang.Compiler.Ast.StatementModifier) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.StatementModifier"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		if ShouldSerialize(node.Condition):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Condition"),
					Serialize(node.Condition)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnGotoStatement(node as Boo.Lang.Compiler.Ast.GotoStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.GotoStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Label):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Label"),
					Serialize(node.Label)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnLabelStatement(node as Boo.Lang.Compiler.Ast.LabelStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.LabelStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnBlock(node as Boo.Lang.Compiler.Ast.Block) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Block"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Statements):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Statements"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.StatementCollection", node.Statements)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnDeclarationStatement(node as Boo.Lang.Compiler.Ast.DeclarationStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.DeclarationStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Declaration):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Declaration"),
					Serialize(node.Declaration)));

		if ShouldSerialize(node.Initializer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Initializer"),
					Serialize(node.Initializer)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnMacroStatement(node as Boo.Lang.Compiler.Ast.MacroStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.MacroStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Arguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Arguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionCollection", node.Arguments)))

		if ShouldSerialize(node.Body):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Body"),
					Serialize(node.Body)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnTryStatement(node as Boo.Lang.Compiler.Ast.TryStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.TryStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.ProtectedBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ProtectedBlock"),
					Serialize(node.ProtectedBlock)));

		if ShouldSerialize(node.ExceptionHandlers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ExceptionHandlers"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExceptionHandlerCollection", node.ExceptionHandlers)))

		if ShouldSerialize(node.FailureBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "FailureBlock"),
					Serialize(node.FailureBlock)));

		if ShouldSerialize(node.EnsureBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "EnsureBlock"),
					Serialize(node.EnsureBlock)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnExceptionHandler(node as Boo.Lang.Compiler.Ast.ExceptionHandler) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ExceptionHandler"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Declaration):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Declaration"),
					Serialize(node.Declaration)));

		if ShouldSerialize(node.FilterCondition):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "FilterCondition"),
					Serialize(node.FilterCondition)));

		if ShouldSerialize(node.Flags):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Flags"),
					Serialize(node.Flags)));

		if ShouldSerialize(node.Block):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Block"),
					Serialize(node.Block)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnIfStatement(node as Boo.Lang.Compiler.Ast.IfStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.IfStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Condition):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Condition"),
					Serialize(node.Condition)));

		if ShouldSerialize(node.TrueBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "TrueBlock"),
					Serialize(node.TrueBlock)));

		if ShouldSerialize(node.FalseBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "FalseBlock"),
					Serialize(node.FalseBlock)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnUnlessStatement(node as Boo.Lang.Compiler.Ast.UnlessStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.UnlessStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Condition):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Condition"),
					Serialize(node.Condition)));

		if ShouldSerialize(node.Block):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Block"),
					Serialize(node.Block)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnForStatement(node as Boo.Lang.Compiler.Ast.ForStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ForStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Declarations):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Declarations"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.DeclarationCollection", node.Declarations)))

		if ShouldSerialize(node.Iterator):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Iterator"),
					Serialize(node.Iterator)));

		if ShouldSerialize(node.Block):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Block"),
					Serialize(node.Block)));

		if ShouldSerialize(node.OrBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "OrBlock"),
					Serialize(node.OrBlock)));

		if ShouldSerialize(node.ThenBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ThenBlock"),
					Serialize(node.ThenBlock)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnWhileStatement(node as Boo.Lang.Compiler.Ast.WhileStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.WhileStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Condition):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Condition"),
					Serialize(node.Condition)));

		if ShouldSerialize(node.Block):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Block"),
					Serialize(node.Block)));

		if ShouldSerialize(node.OrBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "OrBlock"),
					Serialize(node.OrBlock)));

		if ShouldSerialize(node.ThenBlock):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ThenBlock"),
					Serialize(node.ThenBlock)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnBreakStatement(node as Boo.Lang.Compiler.Ast.BreakStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.BreakStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnContinueStatement(node as Boo.Lang.Compiler.Ast.ContinueStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ContinueStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnReturnStatement(node as Boo.Lang.Compiler.Ast.ReturnStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ReturnStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnYieldStatement(node as Boo.Lang.Compiler.Ast.YieldStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.YieldStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnRaiseStatement(node as Boo.Lang.Compiler.Ast.RaiseStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.RaiseStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Exception):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Exception"),
					Serialize(node.Exception)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnUnpackStatement(node as Boo.Lang.Compiler.Ast.UnpackStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.UnpackStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		if ShouldSerialize(node.Declarations):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Declarations"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.DeclarationCollection", node.Declarations)))

		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnExpressionPair(node as Boo.Lang.Compiler.Ast.ExpressionPair) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ExpressionPair"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.First):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "First"),
					Serialize(node.First)));

		if ShouldSerialize(node.Second):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Second"),
					Serialize(node.Second)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnMethodInvocationExpression(node as Boo.Lang.Compiler.Ast.MethodInvocationExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.MethodInvocationExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		if ShouldSerialize(node.Arguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Arguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionCollection", node.Arguments)))

		if ShouldSerialize(node.NamedArguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "NamedArguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionPairCollection", node.NamedArguments)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnUnaryExpression(node as Boo.Lang.Compiler.Ast.UnaryExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.UnaryExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Operator):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Operator"),
					Serialize(node.Operator)));

		if ShouldSerialize(node.Operand):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Operand"),
					Serialize(node.Operand)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnBinaryExpression(node as Boo.Lang.Compiler.Ast.BinaryExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.BinaryExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Operator):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Operator"),
					Serialize(node.Operator)));

		if ShouldSerialize(node.Left):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Left"),
					Serialize(node.Left)));

		if ShouldSerialize(node.Right):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Right"),
					Serialize(node.Right)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnConditionalExpression(node as Boo.Lang.Compiler.Ast.ConditionalExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ConditionalExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Condition):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Condition"),
					Serialize(node.Condition)));

		if ShouldSerialize(node.TrueValue):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "TrueValue"),
					Serialize(node.TrueValue)));

		if ShouldSerialize(node.FalseValue):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "FalseValue"),
					Serialize(node.FalseValue)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnReferenceExpression(node as Boo.Lang.Compiler.Ast.ReferenceExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ReferenceExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnMemberReferenceExpression(node as Boo.Lang.Compiler.Ast.MemberReferenceExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.MemberReferenceExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnGenericReferenceExpression(node as Boo.Lang.Compiler.Ast.GenericReferenceExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.GenericReferenceExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		if ShouldSerialize(node.GenericArguments):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "GenericArguments"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.TypeReferenceCollection", node.GenericArguments)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnStringLiteralExpression(node as Boo.Lang.Compiler.Ast.StringLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.StringLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCharLiteralExpression(node as Boo.Lang.Compiler.Ast.CharLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CharLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnTimeSpanLiteralExpression(node as Boo.Lang.Compiler.Ast.TimeSpanLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.TimeSpanLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnIntegerLiteralExpression(node as Boo.Lang.Compiler.Ast.IntegerLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.IntegerLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		if ShouldSerialize(node.IsLong):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsLong"),
					Serialize(node.IsLong)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnDoubleLiteralExpression(node as Boo.Lang.Compiler.Ast.DoubleLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.DoubleLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		if ShouldSerialize(node.IsSingle):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsSingle"),
					Serialize(node.IsSingle)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnNullLiteralExpression(node as Boo.Lang.Compiler.Ast.NullLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.NullLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnSelfLiteralExpression(node as Boo.Lang.Compiler.Ast.SelfLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SelfLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnSuperLiteralExpression(node as Boo.Lang.Compiler.Ast.SuperLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SuperLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnBoolLiteralExpression(node as Boo.Lang.Compiler.Ast.BoolLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.BoolLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnRELiteralExpression(node as Boo.Lang.Compiler.Ast.RELiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.RELiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Value):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Value"),
					Serialize(node.Value)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	internal def SerializeSpliceExpression(node as Boo.Lang.Compiler.Ast.SpliceExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SpliceExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	internal def SerializeSpliceTypeReference(node as Boo.Lang.Compiler.Ast.SpliceTypeReference) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SpliceTypeReference"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.IsPointer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "IsPointer"),
					Serialize(node.IsPointer)));

		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	internal def SerializeSpliceMemberReferenceExpression(node as Boo.Lang.Compiler.Ast.SpliceMemberReferenceExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SpliceMemberReferenceExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		if ShouldSerialize(node.NameExpression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "NameExpression"),
					Serialize(node.NameExpression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	internal def SerializeSpliceTypeMember(node as Boo.Lang.Compiler.Ast.SpliceTypeMember) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SpliceTypeMember"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.TypeMember):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "TypeMember"),
					Serialize(node.TypeMember)));

		if ShouldSerialize(node.NameExpression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "NameExpression"),
					Serialize(node.NameExpression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	internal def SerializeSpliceTypeDefinitionBody(node as Boo.Lang.Compiler.Ast.SpliceTypeDefinitionBody) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SpliceTypeDefinitionBody"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	internal def SerializeSpliceParameterDeclaration(node as Boo.Lang.Compiler.Ast.SpliceParameterDeclaration) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SpliceParameterDeclaration"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.ParameterDeclaration):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "ParameterDeclaration"),
					Serialize(node.ParameterDeclaration)));

		if ShouldSerialize(node.NameExpression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "NameExpression"),
					Serialize(node.NameExpression)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnExpressionInterpolationExpression(node as Boo.Lang.Compiler.Ast.ExpressionInterpolationExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ExpressionInterpolationExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Expressions):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expressions"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionCollection", node.Expressions)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnHashLiteralExpression(node as Boo.Lang.Compiler.Ast.HashLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.HashLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Items):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Items"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionPairCollection", node.Items)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnListLiteralExpression(node as Boo.Lang.Compiler.Ast.ListLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ListLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Items):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Items"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionCollection", node.Items)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCollectionInitializationExpression(node as Boo.Lang.Compiler.Ast.CollectionInitializationExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CollectionInitializationExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Collection):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Collection"),
					Serialize(node.Collection)));

		if ShouldSerialize(node.Initializer):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Initializer"),
					Serialize(node.Initializer)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnArrayLiteralExpression(node as Boo.Lang.Compiler.Ast.ArrayLiteralExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ArrayLiteralExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Items):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Items"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.ExpressionCollection", node.Items)))

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnGeneratorExpression(node as Boo.Lang.Compiler.Ast.GeneratorExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.GeneratorExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Expression):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Expression"),
					Serialize(node.Expression)));

		if ShouldSerialize(node.Declarations):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Declarations"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.DeclarationCollection", node.Declarations)))

		if ShouldSerialize(node.Iterator):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Iterator"),
					Serialize(node.Iterator)));

		if ShouldSerialize(node.Filter):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Filter"),
					Serialize(node.Filter)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnExtendedGeneratorExpression(node as Boo.Lang.Compiler.Ast.ExtendedGeneratorExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.ExtendedGeneratorExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Items):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Items"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.GeneratorExpressionCollection", node.Items)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnSlice(node as Boo.Lang.Compiler.Ast.Slice) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.Slice"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Begin):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Begin"),
					Serialize(node.Begin)));

		if ShouldSerialize(node.End):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "End"),
					Serialize(node.End)));

		if ShouldSerialize(node.Step):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Step"),
					Serialize(node.Step)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnSlicingExpression(node as Boo.Lang.Compiler.Ast.SlicingExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.SlicingExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		if ShouldSerialize(node.Indices):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Indices"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.SliceCollection", node.Indices)))

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnTryCastExpression(node as Boo.Lang.Compiler.Ast.TryCastExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.TryCastExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCastExpression(node as Boo.Lang.Compiler.Ast.CastExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CastExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Target):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Target"),
					Serialize(node.Target)));

		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnTypeofExpression(node as Boo.Lang.Compiler.Ast.TypeofExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.TypeofExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Type):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Type"),
					Serialize(node.Type)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCustomStatement(node as Boo.Lang.Compiler.Ast.CustomStatement) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CustomStatement"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifier):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifier"),
					Serialize(node.Modifier)));

		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnCustomExpression(node as Boo.Lang.Compiler.Ast.CustomExpression) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.CustomExpression"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		Push(mie);

	[System.CodeDom.Compiler.GeneratedCodeAttribute("Boo astgen.boo", "1")]
	override public def OnStatementTypeMember(node as Boo.Lang.Compiler.Ast.StatementTypeMember) as void:
		mie = MethodInvocationExpression(
				node.LexicalInfo,
				CreateReference(node, "Boo.Lang.Compiler.Ast.StatementTypeMember"))
		mie.Arguments.Add(Serialize(node.LexicalInfo))
		if ShouldSerialize(node.Modifiers):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Modifiers"),
					Serialize(node.Modifiers)));

		if ShouldSerialize(node.Name):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Name"),
					Serialize(node.Name)));

		if ShouldSerialize(node.Attributes):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Attributes"),
					SerializeCollection(node, "Boo.Lang.Compiler.Ast.AttributeCollection", node.Attributes)))

		if ShouldSerialize(node.Statement):
			mie.NamedArguments.Add(
				ExpressionPair(
					CreateReference(node, "Statement"),
					Serialize(node.Statement)));

		Push(mie);

